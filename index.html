<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Prueba de Three JS</title>
  <script type="text/javascript" src="js/three.js"></script>
  <script type="text/javascript" src="js/OBJMTLLoader.js"></script>
  <script type="text/javascript" src="js/MyOBJLoader.js"></script>
  <script  type="text/javascript" src="js/DDSLoader.js"></script>
  <script  type="text/javascript" src="js/MTLLoader.js"></script>

  <script type="text/javascript" src="js/hammer.js"></script>
  
  <script type="text/javascript" src="js/stands.js"></script>

  <script type="text/javascript" src="engine.js"></script>
  <script type="text/javascript" src="character_controller.js"></script>

  <!--
  <script type="text/javascript" src="http://chandlerprall.github.io/Physijs/physi.js"></script>
  <script type="text/javascript" src="http://chandlerprall.github.io/Physijs/examples/js/stats.js"></script>S
  <script type="text/javascript" src="physijs_worker.js"></script>
  <script type="text/javascript" src="ammo.js"></script>
  -->

  <script id="vertexShader" type="x-shader/x-vertex">
  varying vec2 vUv;
  void main() {
    vUv = uv;
    gl_Position = projectionMatrix *
          modelViewMatrix * vec4(position, 1.0 );
  }
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
  precision highp float;
  varying vec2 vUv;
  uniform sampler2D colTex;
  uniform sampler2D shadTex;
  void main(void) {
    gl_FragColor = texture2D(colTex, vUv) * texture2D(shadTex, vUv);
  }
</script>

</head>
<body id="body">
<div id="myElement"  style="background-color:#cccccc;height:200px;width:200px;overflow:hidden; display: none;"></div>
<p>Dragging: <span id="draggingSpan"></span></p>
<p>DeltaX: <span id="deltax"></span></p>
<p>DeltaY: <span id="deltay"></span></p>
<h1>Prueba de Three JS</h1>
<div id="renderDiv"></div>

<p>
<strong>Controles:</strong>
Para moverse, usar las teclas W, A, S y D, o las flechas.
Para mover la cámara, arrastrar con el mouse sobre el juego.
</p>
<p>Distancia: <span id="distanceSpan"></span></p>

</body>
<script type="text/javascript">

  Engine.init({container: renderDiv, fps: 15});

  var boxGeom = new THREE.BoxGeometry(0.5,1.6,0.5);
  var boxMat = new THREE.MeshBasicMaterial({color:0x0000ff});
  var cube = new THREE.Mesh(boxGeom, boxMat);
  cube.position.y = 0.8;
  cube.position.x = 10;
  cube.position.z = 10;

  var stand01;
  var stand02;
  var pabellon;
  var velocidadDesplazamiento = 0.3;
  var loaded = false

  //*/ Modelo simple de la Expo
    var loader = new THREE.OBJMTLLoader();
    loader.load( 'fachada/fachada.obj', 'fachada/fachada.mtl', function ( object ) {

      //object.position.y = -80;
      pabellon = object;
      pabellon.scale.x = 0.024;
      pabellon.scale.y = 0.024;
      pabellon.scale.z = 0.024;
      Engine.scene.add( pabellon );

    }, onProgress, onError );
  //*/
  
  /*/ Modelo de la Expo Completa
    var loader = new THREE.JSONLoader();
    loader.load('expo/expo_completa.js', function(obj, mats) {
      window.matz = mats;
      console.log(window.matz);
      for (var i = 0; i < mats.length; i++) {
        mats[i].opacity = 1;
        mats[i].transparent = false;
      }
      var nmat = new THREE.MeshFaceMaterial( mats );
      pabellon = new THREE.Mesh(obj, nmat);
      Engine.scene.add( pabellon );
    }); 
  //*/

  //--------------------------------------------------------------------------------

  /*/ Añadir Stands
    LoadStand("stand01.js", "textures/diff01.png",
              "textures/occ01.png", function (obj) {
      stand01 = obj;
      setLoaded();
    });

    LoadStand("stand02.js", "textures/diff02.png",
              "textures/occ02.png", function (obj) {
      stand02 = obj;
      setLoaded();
    });
  //*/

  addCube();

  var caster = new THREE.Raycaster();
  var casterBack = new THREE.Raycaster();
  var casterLeft = new THREE.Raycaster();
  var casterRight = new THREE.Raycaster();
  var ray = new THREE.Vector3();
  var rayBack = new THREE.Vector3();
  var rayRight = new THREE.Vector3();
  var rayLeft = new THREE.Vector3();
  var collidables = [stand02];
  var collisions, collisionsBack, collisionsRight, collisionsLeft;
  var pause = false;

  var arrow = new THREE.ArrowHelper(ray, new THREE.Vector3(0,0,0), 10);
  Engine.scene.add(arrow);

  var arrowBack = new THREE.ArrowHelper(rayBack, new THREE.Vector3(0,0,0), 10);
  Engine.scene.add(arrowBack);

  var arrowLeft = new THREE.ArrowHelper(rayBack, new THREE.Vector3(0,0,0), 10);
  Engine.scene.add(arrowLeft);

  var arrowRight = new THREE.ArrowHelper(rayBack, new THREE.Vector3(0,0,0), 10);
  Engine.scene.add(arrowRight);

  var controller = new CharacterController({mesh: cube, cam: Engine.camera, velocity: 3, distance: 4});
       var k = 0;
  function render(delta) {
    //eventosKey();

    controller.updatePosition(delta);
    controller.updateMouse();
    controller.updateCamera();

    /*
    ray.x = Math.sin(cube.rotation.y);
    ray.z = Math.cos(cube.rotation.y);

    rayBack.x = Math.sin(cube.rotation.y + Math.PI);
    rayBack.z = Math.cos(cube.rotation.y + Math.PI);

    rayLeft.x = Math.sin(cube.rotation.y + (Math.PI*1.5));
    rayLeft.z = Math.cos(cube.rotation.y + (Math.PI*1.5));

    rayRight.x = Math.sin(cube.rotation.y + (Math.PI*0.5));
    rayRight.z = Math.cos(cube.rotation.y + (Math.PI*0.5));

    caster.set(cube.position, ray);
    casterBack.set(cube.position, rayBack);
    casterLeft.set(cube.position, rayLeft);
    casterRight.set(cube.position, rayRight);

    arrow.setDirection(ray);
    arrow.position.x = cube.position.x;
    arrow.position.z = cube.position.z;
    arrow.position.y = cube.position.y;

    arrowBack.setDirection(rayBack);
    arrowBack.position.x = cube.position.x;
    arrowBack.position.z = cube.position.z;
    arrowBack.position.y = cube.position.y;

    arrowRight.setDirection(rayRight);
    arrowRight.position.x = cube.position.x;
    arrowRight.position.z = cube.position.z;
    arrowRight.position.y = cube.position.y;

    arrowLeft.setDirection(rayLeft);
    arrowLeft.position.x = cube.position.x;
    arrowLeft.position.z = cube.position.z;
    arrowLeft.position.y = cube.position.y;

    if (pabellon) {

      collisions = caster.intersectObject(pabellon, true);
      collisionsBack = casterBack.intersectObject(pabellon, true);
      collisionsLeft = casterBack.intersectObject(pabellon, true);
      collisionsRight = casterBack.intersectObject(pabellon, true);

      if (collisions.length > 0) {
        if( collisions[0].distance < 0.7 || collisionsBack[0].distance < 0.7 || collisionsLeft[0].distance < 0.7 || collisionsRight[0].distance < 0.7 ) 
        {

          if(keyscoll.up){band.up = true; band.down = band.left = band.left = false;}
          if(keyscoll.down){band.down = true; band.up = band.left = band.left = false;}
          if(keyscoll.left){band.left = true; band.down = band.up = band.left = false;}
          if(keyscoll.right){band.right = true; band.down = band.left = band.up = false;}
        }else{
          band.right = band.down = band.left = band.up = false;
        }  
        } 
      if (collisions.length > 0) {


        distanceSpan.textContent = collisions[0].distance;
      } else {
        distanceSpan.textContent = "NULL";
      }
    }
    */
  }

  Engine.update = render;
  Engine.start();


</script>
</html>