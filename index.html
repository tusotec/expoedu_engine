<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Expo Virtual Demo</title>
  <!-- three.js 71 -->
  <!--<script type="text/javascript" src="js/three.73.js"></script>-->
  <script type="text/javascript" src="three_75.js"></script>
  <!-- Hammer.JS - v2.0.4 -->
  <script type="text/javascript" src="js/hammer.js"></script>

  <!-- Importadores -->
  <script type="text/javascript" src="js/OBJMTLLoader.js"></script>
  <script type="text/javascript" src="js/MyOBJLoader.js"></script>
  <script  type="text/javascript" src="js/MTLLoader.js"></script>

  <!-- Alternative Renderers -->
  <script  type="text/javascript" src="js/Projector.js"></script>
  <script  type="text/javascript" src="js/CanvasRenderer.js"></script>
  <script  type="text/javascript" src="js/SoftwareRenderer.js"></script>

  <script type="text/javascript" src="engine.js"></script>
  <script type="text/javascript" src="input_manager.js"></script>
  <script type="text/javascript" src="character_controller.js"></script>

  <script type="text/javascript" src="expo.js"></script>
  <script type="text/javascript" src="stands.js"></script>

  <link rel="stylesheet" type="text/css" href="main.css">

</head>
<body id="body">
<div id="gameContent">
  <div id="hud">
    <!--<h1>Expo Virtual Demo</h1>-->
    <div id="help">
      <span id="loadSpan"></span>
      <div hidden>
        <p>
          <button onclick="loadFunc()">Load Stands</button>
          Start: <input id="startSpan">
          Amount: <input id="amountSpan">
          <button onclick="removeStands()">Remove Stands</button>
        </p>
      </div>
      <p id="controlDiv">
        <button onclick="Engine.loadAll()">Load All</button><br/>
        <strong>Controles:</strong><br/>
        <strong>PC:</strong>
        Para moverse, usar las teclas W, A, S y D, o las flechas.
        Para mover la cámara, arrastrar con el mouse sobre el juego.<br/>
        <strong>Móvil:</strong>
        Para mover la cámara, arrastrar sobre la pantalla del juego.
        Para moverse, arrastrar sobre el joystick en la esquina inferior derecha.
      </p>
    </div>
    <div id="controles">
      <button onclick="Engine.pause()">Pausa</button>
      <button onclick="help.hidden=!help.hidden">Mostrar Ayuda</button>
      <button onclick="loadStands()">Cargar Stands</button>
      <button onclick="robot.position.set(0,0,0)">Traer Robot</button>
    </div>
    <div id="joystick"> <div></div> </div>
  </div>
  <div id="renderDiv"></div>
</div>

<div id="image-div" hidden>
  <style type="text/css">
    #image-main {
      width: 500px;
      height: 500px;
      position:relative;
    }
    #image-cursor {
      width:10px;height:10px;background:#00ff00;position:absolute;z-index:20;
    }
    #image-cursor div {
      width:6px;height:6px;top:2px;left:2px;background:#0000ff;position:relative;
    }
    #image-main img {
      width:100%; height:100%;
    }
  </style>
  <div id="image-main">
    <div id="image-cursor">
      <div></div>
    </div>
    <img src="textures/diff01.png">
  </div>
  X:<input id="xin">
  Y:<input id="yin">
  <button onclick="apply()">Buscar Coordenadas</button>
  <script type="text/javascript">
    console.log("Hola Mundo!");

    function apply (xa, ya) {
      if (xa == undefined) {
        xa = Number(xin.value);
      }
      if (ya == undefined) {
        ya = Number(yin.value);
      }
      var x = (xa);
      var y = 1-(ya);
      x = Math.floor(x*500);
      y = Math.floor(y*500);
      //console.log({x, y});
      var cursor = document.getElementById("image-cursor");
      cursor.style.left = (x-5) + "px";
      cursor.style.top = (y-5) + "px";
    }
  </script>
</div>



<p hidden>Distancia: <span id="distanceSpan"></span></p>


</body>
<script type="text/javascript">

  var getParams = {}
  location.search.substr(1).split("&").forEach( function(x) {
    var sts = x.split("=");
    getParams[sts[0]] = sts[1];
  });

  var lightExpo = "light" in getParams;
  var software = "software" in getParams;

  var modelos_light = [
    {url: "expo/ext_bloques_edificio.json", occ: "expo/ext_bloques_occ.jpg"},
    {url: "expo/ext_arcos_edificio.json", occ: "expo/ext_arcos_occ.jpg"},
    {url: "expo/pab_estructura_techo.json", occ: "expo/ext_cielo_occ.jpg"},
    {url: "expo/ext_vidrios_edificio_2.json", occ: "expo/ext_vidrios_occ.jpg"},
    {url: "expo/ext_vidrios_edificio.json", occ: "expo/ext_vidrios_occ.jpg"},
    {url: "expo/ext_piso_entrada.json", occ: "expo/ext_piso_entrada_occ.jpg"},
    {url: "expo/pab_piso.json", occ: "expo/pab_piso_occ.jpg"}
  ]

  if (lightExpo) { modelos = modelos_light; }

  Engine.init({container: renderDiv, fps: 15, width: 1024, height: 720, webgl: !software});

  var boxGeom = new THREE.BoxGeometry(0.5,1.6,0.5);
  var boxMat = new THREE.MeshBasicMaterial({color:0x0000ff});
  var cube = new THREE.Mesh(boxGeom, boxMat);

  var stand01;
  var stand02;
  var pabellon;
  var velocidadDesplazamiento = 0.3;
  var loaded = false

  var clickables = [];

  //*/ Cargador de la expo por partes
    var loader = new THREE.JSONLoader();

    var defaultLoaderFunc = function (model) {
      Engine.scene.add(model);
      clickables.push(model);
    }

    function loadObject (modelo) {
      //var occ = THREE.ImageUtils.loadTexture(modelo.occ)
      modelo.type = modelo.type || "json";
      var diff = THREE.ImageUtils.loadTexture(modelo.diff);
      var occ = modelo.occ ? THREE.ImageUtils.loadTexture(modelo.occ) : undefined;
      if (modelo.type == "obj") {
        var mat = new THREE.MeshPhongMaterial({
          map: diff,
          lightMap: occ
        });
        Engine.objLoad(modelo.url, mat, function (obj) {
          window.loadedObj = obj;
          Engine.scene.add(obj);
        })
      } else {
        Engine.jsonLoad(modelo.url, function(obj, mats) {
          var mat = new THREE.MeshFaceMaterial(mats);

          for (var i = 0; i < mats.length; i++) {
            var xmat = mats[i];
            var nmat = new THREE.MeshBasicMaterial();
            nmat.color.setRGB(1.1,1.1,1.1);
            //nmat.color.setRGB(1,1,1);
            nmat.map = xmat.lightMap;
            //xmat.lightMap = undefined;
            nmat.aoMap = occ;
            var map = nmat.map;
            map.wrapT = THREE.RepeatWrapping;
            map.wrapS = THREE.RepeatWrapping;
            nmat.transparent = xmat.transparent;
            nmat.depthTest = xmat.depthTest;
            nmat.depthWrite = xmat.depthWrite;
            mats[i] = nmat;
          }

          model = new THREE.Mesh(obj, mat);
          model.position.set(modelo.x || 0, modelo.y || 0, modelo.z || 0);
          var func = modelo.func || defaultLoaderFunc;
          func(model);
        });
      }
    }

    for (var i = 0; i < modelos.length; i++) {
      loadObject(modelos[i]);
    }
  //*/


  //*/ Cargar Robot y personajes
  var robot;
  var botgeom;
  var botloader = new THREE.JSONLoader();
  var animations;
  var controller;

  if (getParams.bot === "false") {
    controller = new CharacterController({mesh: cube, cam: Engine.camera,
      velocity: 3, distance: 4, yOff: 1});
    var k = 0;
  } else {
    var n = getParams.bot;
    if (n == undefined) {n = "1"};
    var url = "robots/expo_robot_" + n + ".json";
    Engine.jsonLoad(url, function(geom, mats) {
      botgeom = geom;
      //var mat = new THREE.MeshFaceMaterial(mats);
      for (var i = 0; i < mats.length; i++) {
        //mats[i].skinning = true;
      }
      //mat = boxMat;
      mat = mats[0];
      mat.skinning = true;
      //mat.aoMap = mat.lightMap;
      geom.faceVertexUvs[1] = geom.faceVertexUvs[0]
      robot = new THREE.SkinnedMesh(geom, mat);
      var rAnimations = geom.animations.map(function (x) {
        //return new THREE.Animation(robot, x);
        return x;
      });
      robot.scale.set(0.8,0.8,0.8);
      Engine.scene.add(robot);
      controller = new CharacterController({
        mesh: robot, cam: Engine.camera, animations: rAnimations,
        velocity: 3, distance: 4, yOff: 0.8});
      });
  }

  function loadStand (url, myFunc) {
    var loader = new THREE.JSONLoader();
    loader.load(url, function(obj, mats) {
        var mat = new THREE.MeshFaceMaterial(mats);
        model = new THREE.Mesh(obj, mat);
        myFunc(model);
    });
  }

  var loadStands = function () {
    stands.forEach(function (x) {
      Engine.scene.add(x);
    });
  }

  var mouseVector = new THREE.Vector2();
  var caster = new THREE.Raycaster();
  var arrow = new THREE.ArrowHelper(caster.ray.direction, new THREE.Vector3(0,0,0), 10);
  //Engine.scene.add(arrow);

  var clickData = {};
  /*
  Input.onclick = function (dt) {
    mouseVector.set(dt.x, -dt.y);
    //mouseVector.set(0, 0);
    caster.setFromCamera(mouseVector, Engine.camera);
    arrow.position.copy(caster.ray.origin);
    arrow.setDirection(caster.ray.direction);
    var intersects = caster.intersectObjects( clickables );
    if (intersects.length > 0) {
      var intersect = intersects[0];
      var object = intersect.object;
      var index = intersect.faceIndex;
      var allUvs = object.geometry.faceVertexUvs[0];
      var uvs = allUvs[index];
      clickData.intersect = intersect;
      clickData.
      clickData.uvs = uvs;
      var textureCoords = {
        x: (uvs[0].x + uvs[1].x + uvs[2].x)/3,
        y: (uvs[0].y + uvs[1].y + uvs[2].y)/3,
      };
      clickData.coords = textureCoords;
      //console.log(textureCoords);
      apply(textureCoords.x, textureCoords.y);
    }
  }
  //*/

  //--------------------------------------------------------------------------------

  function render(delta) {
    if (controller) {
      controller.update(delta);
    }
  }

  Engine.update = render;
  Engine.loadUpdate = function (loaded, toLoad) {
    loadSpan.textContent = "loaded: " + loaded + "/" + toLoad;
  }
  Engine.onLoad(function () { Engine.start(); });

  Engine.loadAll();
  


</script>
</html>